# import random
# from collections import Counter
#
#
# a =[]
# b =[1,2,3,4,5,6,7,8,9,0,11,12,13,14,15,16,17,18,19,20]
# c =[1,8,3,11,5,7,20]
# d = [1,2,11,13,20]
# for i in range(900):
#     a.append(random.choice(b))
#     a.append(random.choice(c))
#     a.append(random.choice(d))
# a.append(2)
#
# tw = Counter(a).most_common(10)
# print('a = ',a)
# print('tw =',tw)
#
# def ix_tw(tw,a):  # s - top_word, s1 - normform - запоминаем индексы наиболее часто встречающихся элементов
#     s2 =[]
#     for i in range(len(tw)):
#         s2.append([tw[i][0]])
#         for j in range(len(a)):
#             if tw[i][0] == a[j]:
#                 s2[i].append(j)
#     return s2
# x=ix_tw(tw,a)
# print('индексы(х) = ',x)


"""""""""  функция принимает на вход нормализованный список, топ слова и их индексы 
           возвращает  упорядоченный топ список, жадный алгоритм, требует доработки  """""

def breakdown(a,tw,x): #a-корпус,tw-топовые элементы,x - индексы топовых элементов, нулевой - сам элемент

    if int(len(a))%2!=0:      # Если длинна корпуса нечетная удаляем последний элемент
        a.pop(int(len(a)-1)) # это может незначительно повлиять на результат,
                             # но позволит исключить ошибку добавления лишнего элемента
                             # в Z5
    z5 = [] # z5 - массив с упорядоченными элементами для замены в основном корпусе
    step = int(len(a) / len(tw))

    for i in range(0, len(a), step): #перебор корпуса с шагом (длинна корпуса/количество топ-Элементов
        z1=[]
        for j in range(len(x)):  # перебираем массив индексов
            z1.append(str(x[j][0]))
            z = 0  #счетчик встреч элемента tw в корпусе по индексам
            for j1 in range(1,len(x[j])): # перебираем массив индексов
                if x[j][j1] > i:
                    z = z + 1
            z1.append(z)


        for j in range(len(x)):  # перебираем массив индексов
            z1.append(str(x[j][0]))
            z = 0  # счетчик встреч элемента tw в корпусе по индексам
            for j1 in range(1,len(x[j])):  # перебираем массив индексов
                if x[j][j1] > (i + step):
                    z = z + 1
            z1.append(z)
        # получили два массива в одном, len(z1)/2 разница числовых значений половинок массива
        # показывает сколько элементов встречается в части корпуса длинной len(a)/len(tw)
        # далее работаем с z1:
        z2 = z1[0:(int(len(z1)/2))]
        z3 = z1[int(len(z1)/2):len(z1)] # - разбиваем z1 на половинки z2 - первая, z3 - вторая
        l2 = 0 #сумма всех элементов в z3

        for l in range(1,len(z3),2):
            l2 = l2+z3[l]
        z4 =[]
        for l in range(1,len(z2),2):
            l3 =0
            l3 = l2+z2[l]-z3[l]
            z4.append(l3)   # z4 - список сумм элементов z3 с поочередной заменой каждого элемента
                            # из z3 на z2
                            # далее необходимо выбрать наибольшую сумму - подставленный элемент из z2
                            # самый влиятельный начиная с текущего участка
                            # в дальнейщем для улучшения функции Возможно находить Мин. сумму
                            # по ней определять элемент которому нужно добавить ВЕС

        ind = (z4.index(max(z4)))*2 # индекс наибольшей суммы (умножаем на2 для извлечения элемента из z2)
        z5.append(z2[ind])

        #- удаляем проиндексированный элемент из TW и X

        for l4 in range(len(z5)):
            for l3 in range(len(tw)-1):
                if z5[l4] == str(tw[l3][0]):
                    tw.pop(l3)
                    x.pop(l3)
                    break
                    #иногда возникет ошибка len(tw2) == 2
                    # ???
        if i==(len(a)-step):
            break # выходим из цикла до достижения последней части корпуса, во избежание ошибки

    # return (('tw2 = ',tw),('z5 =',z5),('ind = ',ind),('z4 = ',z4),('z2 = ',z2),('z3 = ',z3))
    return (z5)
# print(raspr(a,tw,x))



